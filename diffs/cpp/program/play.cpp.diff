--- cpp/program/play.cpp [lightvector:master]+++ cpp/program/play.cpp [hzyhhzy:Reversi2022]@@ -9,8 +9,6 @@ #include "../search/searchnode.h"
 #include "../dataio/files.h"
 
-#include "../core/test.h"
-
 using namespace std;
 
 //----------------------------------------------------------------------------------------------------------
@@ -18,8 +16,8 @@ InitialPosition::InitialPosition()
   :board(),hist(),pla(C_EMPTY)
 {}
-InitialPosition::InitialPosition(const Board& b, const BoardHistory& h, Player p, bool plainFork, bool sekiFork, bool hintFork)
-  :board(b),hist(h),pla(p),isPlainFork(plainFork),isSekiFork(sekiFork),isHintFork(hintFork)
+InitialPosition::InitialPosition(const Board& b, const BoardHistory& h, Player p, bool plainFork, bool hintFork)
+  :board(b),hist(h),pla(p),isPlainFork(plainFork),isHintFork(hintFork)
 {}
 InitialPosition::~InitialPosition()
 {}
@@ -29,9 +27,6 @@   for(int i = 0; i<forks.size(); i++)
     delete forks[i];
   forks.clear();
-  for(int i = 0; i<sekiForks.size(); i++)
-    delete sekiForks[i];
-  sekiForks.clear();
 }
 
 void ForkData::add(const InitialPosition* pos) {
@@ -42,41 +37,14 @@   std::lock_guard<std::mutex> lock(mutex);
   if(forks.size() <= 0)
     return NULL;
-  testAssert(forks.size() < 0x1FFFffff);
-  uint32_t r = rand.nextUInt((uint32_t)forks.size());
-  size_t last = forks.size()-1;
+  int r = rand.nextUInt(forks.size());
+  int last = forks.size()-1;
   const InitialPosition* pos = forks[r];
   forks[r] = forks[last];
   forks.resize(forks.size()-1);
   return pos;
 }
 
-void ForkData::addSeki(const InitialPosition* pos, Rand& rand) {
-  std::unique_lock<std::mutex> lock(mutex);
-  if(sekiForks.size() >= 1000) {
-    testAssert(sekiForks.size() < 0x1FFFffff);
-    uint32_t r = rand.nextUInt((uint32_t)sekiForks.size());
-    const InitialPosition* oldPos = sekiForks[r];
-    sekiForks[r] = pos;
-    lock.unlock();
-    delete oldPos;
-  }
-  else {
-    sekiForks.push_back(pos);
-  }
-}
-const InitialPosition* ForkData::getSeki(Rand& rand) {
-  std::lock_guard<std::mutex> lock(mutex);
-  if(sekiForks.size() <= 0)
-    return NULL;
-  testAssert(sekiForks.size() < 0x1FFFffff);
-  uint32_t r = rand.nextUInt((uint32_t)sekiForks.size());
-  size_t last = sekiForks.size()-1;
-  const InitialPosition* pos = sekiForks[r];
-  sekiForks[r] = sekiForks[last];
-  sekiForks.resize(sekiForks.size()-1);
-  return pos;
-}
 
 //------------------------------------------------------------------------------------------------
 
@@ -94,42 +62,13 @@ 
 void GameInitializer::initShared(ConfigParser& cfg, Logger& logger) {
 
-  allowedKoRuleStrs = cfg.getStrings("koRules", Rules::koRuleStrings());
-  allowedScoringRuleStrs = cfg.getStrings("scoringRules", Rules::scoringRuleStrings());
   allowedTaxRuleStrs = cfg.getStrings("taxRules", Rules::taxRuleStrings());
-  allowedMultiStoneSuicideLegals = cfg.getBools("multiStoneSuicideLegals");
-  allowedButtons = cfg.getBools("hasButtons");
-
-  for(size_t i = 0; i < allowedKoRuleStrs.size(); i++)
-    allowedKoRules.push_back(Rules::parseKoRule(allowedKoRuleStrs[i]));
-  for(size_t i = 0; i < allowedScoringRuleStrs.size(); i++)
-    allowedScoringRules.push_back(Rules::parseScoringRule(allowedScoringRuleStrs[i]));
+
   for(size_t i = 0; i < allowedTaxRuleStrs.size(); i++)
     allowedTaxRules.push_back(Rules::parseTaxRule(allowedTaxRuleStrs[i]));
 
-  if(allowedKoRules.size() <= 0)
-    throw IOError("koRules must have at least one value in " + cfg.getFileName());
-  if(allowedScoringRules.size() <= 0)
-    throw IOError("scoringRules must have at least one value in " + cfg.getFileName());
   if(allowedTaxRules.size() <= 0)
     throw IOError("taxRules must have at least one value in " + cfg.getFileName());
-  if(allowedMultiStoneSuicideLegals.size() <= 0)
-    throw IOError("multiStoneSuicideLegals must have at least one value in " + cfg.getFileName());
-  if(allowedButtons.size() <= 0)
-    throw IOError("hasButtons must have at least one value in " + cfg.getFileName());
-
-  {
-    bool hasAreaScoring = false;
-    for(int i = 0; i<allowedScoringRules.size(); i++)
-      if(allowedScoringRules[i] == Rules::SCORING_AREA)
-        hasAreaScoring = true;
-    bool hasTrueButton = false;
-    for(int i = 0; i<allowedButtons.size(); i++)
-      if(allowedButtons[i])
-        hasTrueButton = true;
-    if(!hasAreaScoring && hasTrueButton)
-      throw IOError("If scoringRules does not include AREA, hasButtons must be false in " + cfg.getFileName());
-  }
 
   allowedBSizes = cfg.getInts("bSizes", 2, Board::MAX_LEN);
   allowedBSizeRelProbs = cfg.getDoubles("bSizeRelProbs",0.0,1e100);
@@ -143,13 +82,11 @@ 
   komiMean = cfg.contains("komiMean") ? cfg.getFloat("komiMean",Rules::MIN_USER_KOMI,Rules::MAX_USER_KOMI) : 7.5f;
   komiStdev = cfg.contains("komiStdev") ? cfg.getFloat("komiStdev",0.0f,60.0f) : 0.0f;
-  handicapProb = cfg.contains("handicapProb") ? cfg.getDouble("handicapProb",0.0,1.0) : 0.0;
-  handicapCompensateKomiProb = cfg.contains("handicapCompensateKomiProb") ? cfg.getDouble("handicapCompensateKomiProb",0.0,1.0) : 0.0;
   komiBigStdevProb = cfg.contains("komiBigStdevProb") ? cfg.getDouble("komiBigStdevProb",0.0,1.0) : 0.0;
   komiBigStdev = cfg.contains("komiBigStdev") ? cfg.getFloat("komiBigStdev",0.0f,60.0f) : 10.0f;
   komiAuto = cfg.contains("komiAuto") ? cfg.getBool("komiAuto") : false;
 
-  forkCompensateKomiProb = cfg.contains("forkCompensateKomiProb") ? cfg.getDouble("forkCompensateKomiProb",0.0,1.0) : handicapCompensateKomiProb;
+  forkCompensateKomiProb = cfg.contains("forkCompensateKomiProb") ? cfg.getDouble("forkCompensateKomiProb",0.0,1.0) :0.0;
   sgfCompensateKomiProb = cfg.contains("sgfCompensateKomiProb") ? cfg.getDouble("sgfCompensateKomiProb",0.0,1.0) : forkCompensateKomiProb;
   komiAllowIntegerProb = cfg.contains("komiAllowIntegerProb") ? cfg.getDouble("komiAllowIntegerProb",0.0,1.0) : 1.0;
 
@@ -222,8 +159,7 @@         else {
           bool hashComments = false;
           bool hashParent = false;
-          bool flipIfPassOrWFirst = true;
-          sgf->iterAllUniquePositions(uniqueHashes, hashComments, hashParent, flipIfPassOrWFirst, NULL, posHandler);
+          sgf->iterAllUniquePositions(uniqueHashes, hashComments, hashParent, NULL, posHandler);
         }
       }
       catch(const StringError& e) {
@@ -319,7 +255,6 @@   }
 
   noResultStdev = cfg.contains("noResultStdev") ? cfg.getDouble("noResultStdev",0.0,1.0) : 0.0;
-  numExtraBlackFixed = cfg.contains("numExtraBlackFixed") ? cfg.getInt("numExtraBlackFixed",1,18) : 0;
   drawRandRadius = cfg.contains("drawRandRadius") ? cfg.getDouble("drawRandRadius",0.0,1.0) : 0.0;
 }
 
@@ -370,14 +305,9 @@   }
 }
 
-Rules GameInitializer::randomizeScoringAndTaxRules(Rules rules, Rand& randToUse) const {
-  rules.scoringRule = allowedScoringRules[randToUse.nextUInt((uint32_t)allowedScoringRules.size())];
-  rules.taxRule = allowedTaxRules[randToUse.nextUInt((uint32_t)allowedTaxRules.size())];
-
-  if(rules.scoringRule == Rules::SCORING_AREA)
-    rules.hasButton = allowedButtons[randToUse.nextUInt((uint32_t)allowedButtons.size())];
-  else
-    rules.hasButton = false;
+Rules GameInitializer::randomizeTaxRules(Rules rules, Rand& randToUse) const {
+  rules.taxRule = allowedTaxRules[randToUse.nextUInt(allowedTaxRules.size())];
+
 
   return rules;
 }
@@ -415,15 +345,7 @@ 
 Rules GameInitializer::createRulesUnsynchronized() {
   Rules rules;
-  rules.koRule = allowedKoRules[rand.nextUInt((uint32_t)allowedKoRules.size())];
-  rules.scoringRule = allowedScoringRules[rand.nextUInt((uint32_t)allowedScoringRules.size())];
-  rules.taxRule = allowedTaxRules[rand.nextUInt((uint32_t)allowedTaxRules.size())];
-  rules.multiStoneSuicideLegal = allowedMultiStoneSuicideLegals[rand.nextUInt((uint32_t)allowedMultiStoneSuicideLegals.size())];
-
-  if(rules.scoringRule == Rules::SCORING_AREA)
-    rules.hasButton = allowedButtons[rand.nextUInt((uint32_t)allowedButtons.size())];
-  else
-    rules.hasButton = false;
+  rules.taxRule = allowedTaxRules[rand.nextUInt(allowedTaxRules.size())];
   return rules;
 }
 
@@ -440,14 +362,10 @@     hist = initialPosition->hist;
     pla = initialPosition->pla;
 
-    //No handicap when starting from an initial position.
-    double thisHandicapProb = 0.0;
-    extraBlackAndKomi = PlayUtils::chooseExtraBlackAndKomi(
+    extraBlackAndKomi = PlayUtils::chooseKomi(
       hist.rules.komi, komiStdev, komiAllowIntegerProb,
-      thisHandicapProb, numExtraBlackFixed,
       komiBigStdevProb, komiBigStdev, sqrt(board.x_size*board.y_size), rand
     );
-    assert(extraBlackAndKomi.extraBlack == 0);
     PlayUtils::setKomiWithNoise(extraBlackAndKomi, hist, rand);
     otherGameProps.isSgfPos = false;
     otherGameProps.isHintPos = false;
@@ -493,10 +411,9 @@     const Sgf::PositionSample& startPos = *posSample;
     board = startPos.board;
     pla = startPos.nextPla;
-    hist.clear(board,pla,rules,0);
+    hist.clear(board,pla,rules);
     hist.setInitialTurnNumber(startPos.initialTurnNumber);
     Loc hintLoc = startPos.hintLoc;
-    testAssert(startPos.moves.size() < 0xFFFFFF);
     for(size_t i = 0; i<startPos.moves.size(); i++) {
       bool isLegal = hist.isLegal(board,startPos.moves[i].loc,startPos.moves[i].pla);
       if(!isLegal) {
@@ -504,15 +421,12 @@         hintLoc = Board::NULL_LOC;
         break;
       }
-      hist.makeBoardMoveAssumeLegal(board,startPos.moves[i].loc,startPos.moves[i].pla,NULL);
+      hist.makeBoardMoveAssumeLegal(board,startPos.moves[i].loc,startPos.moves[i].pla);
       pla = getOpp(startPos.moves[i].pla);
     }
 
-    //No handicap when starting from a sampled position.
-    double thisHandicapProb = 0.0;
-    extraBlackAndKomi = PlayUtils::chooseExtraBlackAndKomi(
+    extraBlackAndKomi = PlayUtils::chooseKomi(
       komiMean, komiStdev, komiAllowIntegerProb,
-      thisHandicapProb, numExtraBlackFixed,
       komiBigStdevProb, komiBigStdev, sqrt(board.x_size*board.y_size), rand
     );
     PlayUtils::setKomiWithNoise(extraBlackAndKomi, hist, rand);
@@ -523,7 +437,7 @@     otherGameProps.isFork = false;
     otherGameProps.isHintFork = false;
     otherGameProps.hintLoc = hintLoc;
-    otherGameProps.hintTurn = (int)hist.moveHistory.size();
+    otherGameProps.hintTurn = hist.moveHistory.size();
     otherGameProps.hintPosHash = board.pos_hash;
     makeGameFairProb = sgfCompensateKomiProb;
   }
@@ -532,11 +446,10 @@     int ySize = allowedBSizes[ySizeIdx];
     board = Board(xSize,ySize);
     pla = P_BLACK;
-    hist.clear(board,pla,rules,0);
-
-    extraBlackAndKomi = PlayUtils::chooseExtraBlackAndKomi(
+    hist.clear(board,pla,rules);
+
+    extraBlackAndKomi = PlayUtils::chooseKomi(
       komiMean, komiStdev, komiAllowIntegerProb,
-      handicapProb, numExtraBlackFixed,
       komiBigStdevProb, komiBigStdev, sqrt(board.x_size*board.y_size), rand
     );
     PlayUtils::setKomiWithNoise(extraBlackAndKomi, hist, rand);
@@ -548,15 +461,15 @@     otherGameProps.isHintFork = false;
     otherGameProps.hintLoc = Board::NULL_LOC;
     otherGameProps.hintTurn = -1;
-    makeGameFairProb = extraBlackAndKomi.extraBlack > 0 ? handicapCompensateKomiProb : 0.0;
-  }
-
-  double asymmetricProb = (extraBlackAndKomi.extraBlack > 0) ? playSettings.handicapAsymmetricPlayoutProb : playSettings.normalAsymmetricPlayoutProb;
+    makeGameFairProb =  0.0;
+  }
+
+  double asymmetricProb = playSettings.normalAsymmetricPlayoutProb;
   if(asymmetricProb > 0 && rand.nextBool(asymmetricProb)) {
     assert(playSettings.maxAsymmetricRatio >= 1.0);
     double maxNumDoublings = log(playSettings.maxAsymmetricRatio) / log(2.0);
     double numDoublings = rand.nextDouble(maxNumDoublings);
-    if(extraBlackAndKomi.extraBlack > 0 || rand.nextBool(0.5)) {
+    if(rand.nextBool(0.5)) {
       otherGameProps.playoutDoublingAdvantagePla = C_WHITE;
       otherGameProps.playoutDoublingAdvantage = numDoublings;
     }
@@ -727,11 +640,9 @@ 
     if(nextMatchupsBuf.size() <= 0)
       throw StringError("MatchPairer::getMatchupPairUnsynchronized: no matchups generated");
-    if(nextMatchupsBuf.size() > 0xFFFFFF)
-      throw StringError("MatchPairer::getMatchupPairUnsynchronized: too many matchups");
 
     //Shuffle
-    for(int i = (int)nextMatchupsBuf.size()-1; i >= 1; i--) {
+    for(int i = nextMatchupsBuf.size()-1; i >= 1; i--) {
       int j = (int)rand.nextUInt(i+1);
       pair<int,int> tmp = nextMatchupsBuf[i];
       nextMatchupsBuf[i] = nextMatchupsBuf[j];
@@ -924,15 +835,6 @@     SidePosition* sp = new SidePosition(board,hist,pla,numNeuralNetChangesSoFar);
     extractPolicyTarget(sp->policyTarget, toMoveBot, node, locsBuf, playSelectionValuesBuf);
     extractValueTargets(sp->whiteValueTargets, toMoveBot, node);
-
-    double policySurprise = 0.0, policyEntropy = 0.0, searchEntropy = 0.0;
-    bool success = toMoveBot->getPolicySurpriseAndEntropy(policySurprise, searchEntropy, policyEntropy, node);
-    assert(success);
-    (void)success; //Avoid warning when asserts are disabled
-    sp->policySurprise = policySurprise;
-    sp->policyEntropy = policyEntropy;
-    sp->searchEntropy = searchEntropy;
-
     sp->nnRawStats = computeNNRawStats(toMoveBot, board, hist, pla);
     sp->targetWeight = recordTreeTargetWeight;
     sp->unreducedNumVisits = toMoveBot->getRootVisits();
@@ -975,7 +877,7 @@     if(hist.isLegal(board, moveLoc, pla)) {
       Board copy = board;
       BoardHistory histCopy = hist;
-      histCopy.makeBoardMoveAssumeLegal(copy, moveLoc, pla, NULL);
+      histCopy.makeBoardMoveAssumeLegal(copy, moveLoc, pla);
       Player nextPla = getOpp(pla);
       recordTreePositionsRec(
         gameData,
@@ -1248,7 +1150,6 @@   bool doEndGameIfAllPassAlive, bool clearBotBeforeSearch,
   Logger& logger, bool logSearchInfo, bool logMoves,
   int maxMovesPerGame, const std::function<bool()>& shouldStop,
-  const WaitableFlag* shouldPause,
   const PlaySettings& playSettings, const OtherGameProperties& otherGameProps,
   Rand& gameRand,
   std::function<NNEvaluator*()> checkForNewNNEval,
@@ -1272,7 +1173,6 @@     doEndGameIfAllPassAlive, clearBotBeforeSearch,
     logger, logSearchInfo, logMoves,
     maxMovesPerGame, shouldStop,
-    shouldPause,
     playSettings, otherGameProps,
     gameRand,
     checkForNewNNEval,
@@ -1293,7 +1193,6 @@   bool doEndGameIfAllPassAlive, bool clearBotBeforeSearch,
   Logger& logger, bool logSearchInfo, bool logMoves,
   int maxMovesPerGame, const std::function<bool()>& shouldStop,
-  const WaitableFlag* shouldPause,
   const PlaySettings& playSettings, const OtherGameProperties& otherGameProps,
   Rand& gameRand,
   std::function<NNEvaluator*()> checkForNewNNEval,
@@ -1309,18 +1208,12 @@ 
   if(extraBlackAndKomi.makeGameFairForEmptyBoard) {
     Board b(startBoard.x_size,startBoard.y_size);
-    BoardHistory h(b,pla,startHist.rules,startHist.encorePhase);
+    BoardHistory h(b,pla,startHist.rules);
     //Restore baseline on empty hist, adjust empty hist to fair, then apply to real history.
     PlayUtils::setKomiWithoutNoise(extraBlackAndKomi,h);
     PlayUtils::adjustKomiToEven(botB,botW,b,h,pla,playSettings.compensateKomiVisits,otherGameProps,gameRand);
     extraBlackAndKomi.komiMean = h.rules.komi;
     PlayUtils::setKomiWithNoise(extraBlackAndKomi,hist,gameRand);
-  }
-  if(extraBlackAndKomi.extraBlack > 0) {
-    double extraBlackTemperature = playSettings.handicapTemperature;
-    assert(extraBlackTemperature > 0.0 && extraBlackTemperature < 10.0);
-    PlayUtils::playExtraBlack(botB,extraBlackAndKomi.extraBlack,board,hist,extraBlackTemperature,gameRand);
-    assert(hist.moveHistory.size() == 0);
   }
   if(extraBlackAndKomi.makeGameFair) {
     //Restore baseline on hist, adjust hist to fair, then apply it with noise.
@@ -1329,9 +1222,9 @@     extraBlackAndKomi.komiMean = hist.rules.komi;
     PlayUtils::setKomiWithNoise(extraBlackAndKomi,hist,gameRand);
   }
-  else if((extraBlackAndKomi.extraBlack > 0 || otherGameProps.isFork) &&
+  else if((otherGameProps.isFork) &&
           playSettings.fancyKomiVarying &&
-          gameRand.nextBool(extraBlackAndKomi.extraBlack > 0 ? 0.5 : 0.25)) {
+          gameRand.nextBool(0.25)) {
     double origKomi = hist.rules.komi;
     //Restore baseline on hist, adjust hist to fair, then apply it with noise.
     PlayUtils::setKomiWithoutNoise(extraBlackAndKomi,hist);
@@ -1365,14 +1258,9 @@   gameData->playoutDoublingAdvantagePla = otherGameProps.playoutDoublingAdvantagePla;
   gameData->playoutDoublingAdvantage = otherGameProps.playoutDoublingAdvantage;
 
-  gameData->numExtraBlack = extraBlackAndKomi.extraBlack;
-  gameData->handicapForSgf = extraBlackAndKomi.extraBlack; //overwritten later
   gameData->mode = FinishedGameData::MODE_NORMAL;
-  gameData->beganInEncorePhase = 0;
   gameData->usedInitialPosition = 0;
 
-  if(extraBlackAndKomi.extraBlack > 0)
-    gameData->mode = FinishedGameData::MODE_HANDICAP;
 
   //Might get overwritten next as we also play sgfposes and such with asym mode!
   //So this is just a best efforts to make it more prominent for most of the asymmetric games.
@@ -1420,7 +1308,7 @@         PlayUtils::setKomiWithNoise(extraBlackAndKomi,hist,gameRand);
         double temperature = playSettings.policyInitAreaTemperature;
         assert(temperature > 0.0 && temperature < 10.0);
-        PlayUtils::initializeGameUsingPolicy(botB, botW, board, hist, pla, gameRand, doEndGameIfAllPassAlive, proportionOfBoardArea, temperature);
+        PlayUtils::initializeGameUsingPolicy(botB, botW, board, hist, pla, gameRand, proportionOfBoardArea, temperature);
         hist.setKomi(oldKomi);
       }
       bool shouldCompensate =
@@ -1435,31 +1323,6 @@     }
   }
 
-  //Make sure there's some minimum tiny amount of data about how the encore phases work
-  if(playSettings.forSelfPlay && !otherGameProps.isHintPos && hist.rules.scoringRule == Rules::SCORING_TERRITORY && hist.encorePhase == 0 && gameRand.nextBool(0.04)) {
-    //Play out to go a quite a bit later in the game.
-    double proportionOfBoardArea = 0.25;
-    double temperature = 2.0/3.0;
-    PlayUtils::initializeGameUsingPolicy(botB, botW, board, hist, pla, gameRand, doEndGameIfAllPassAlive, proportionOfBoardArea, temperature);
-
-    if(!hist.isGameFinished) {
-      //Even out the game
-      PlayUtils::adjustKomiToEven(botB, botW, board, hist, pla, playSettings.compensateKomiVisits, otherGameProps, gameRand);
-      extraBlackAndKomi.komiMean = hist.rules.komi;
-      PlayUtils::setKomiWithNoise(extraBlackAndKomi,hist,gameRand);
-
-      //Randomly set to one of the encore phases
-      //Since we played out the game a bunch we should get a good mix of stones that were present or not present at the start
-      //of the second encore phase if we're going into the second.
-      int encorePhase = gameRand.nextInt(1,2);
-      board.clearSimpleKoLoc();
-      hist.clear(board,pla,hist.rules,encorePhase);
-
-      gameData->mode = FinishedGameData::MODE_CLEANUP_TRAINING;
-      gameData->beganInEncorePhase = encorePhase;
-      gameData->usedInitialPosition = 0;
-    }
-  }
 
   //Set in the starting board and history to gameData and both bots
   gameData->startBoard = board;
@@ -1475,21 +1338,21 @@ 
   vector<SidePosition*> sidePositionsToSearch;
 
+  vector<double> historicalMctsDrawrate;
   vector<double> historicalMctsWinLossValues;
   vector<double> historicalMctsLeads;
   vector<double> historicalMctsScoreStdevs;
+  vector<double> policySurpriseByTurn;
   vector<ReportedSearchValues> rawNNValues;
 
   ClockTimer timer;
+
+  bool drawEarlyEndGame = gameRand.nextBool(0.9);
 
   //Main play loop
   for(int i = 0; i<maxMovesPerGame; i++) {
-    if(doEndGameIfAllPassAlive)
-      hist.endGameIfAllPassAlive(board);
     if(hist.isGameFinished)
       break;
-    if(shouldPause != nullptr)
-      shouldPause->waitUntilFalse();
     if(shouldStop != nullptr && shouldStop())
       break;
 
@@ -1541,15 +1404,7 @@       gameData->nnRawStatsByTurn.push_back(computeNNRawStats(toMoveBot, board, hist, pla));
 
       gameData->targetWeightByTurn.push_back(limits.targetWeight);
-
-      double policySurprise = 0.0, policyEntropy = 0.0, searchEntropy = 0.0;
-      bool success = toMoveBot->getPolicySurpriseAndEntropy(policySurprise, searchEntropy, policyEntropy);
-      assert(success);
-      (void)success; //Avoid warning when asserts are disabled
-      gameData->policySurpriseByTurn.push_back(policySurprise);
-      gameData->policyEntropyByTurn.push_back(policyEntropy);
-      gameData->searchEntropyByTurn.push_back(searchEntropy);
-
+      policySurpriseByTurn.push_back(toMoveBot->getPolicySurprise());
       rawNNValues.push_back(toMoveBot->getRootRawNNValuesRequireSuccess());
 
       //Occasionally fork off some positions to evaluate
@@ -1561,8 +1416,8 @@         Loc banMove = loc;
         sidePositionForkLoc = chooseRandomForkingMove(nnOutput, board, hist, pla, gameRand, banMove);
         if(sidePositionForkLoc != Board::NULL_LOC) {
-          SidePosition* sp = new SidePosition(board,hist,pla,(int)gameData->changedNeuralNets.size());
-          sp->hist.makeBoardMoveAssumeLegal(sp->board,sidePositionForkLoc,sp->pla,NULL);
+          SidePosition* sp = new SidePosition(board,hist,pla,gameData->changedNeuralNets.size());
+          sp->hist.makeBoardMoveAssumeLegal(sp->board,sidePositionForkLoc,sp->pla);
           sp->pla = getOpp(sp->pla);
           if(sp->hist.isGameFinished) delete sp;
           else sidePositionsToSearch.push_back(sp);
@@ -1579,7 +1434,7 @@           board,hist,pla,
           toMoveBot,
           playSettings.recordTreeThreshold,playSettings.recordTreeTargetWeight,
-          (int)gameData->changedNeuralNets.size(),
+          gameData->changedNeuralNets.size(),
           locsBuf,playSelectionValuesBuf,
           loc,sidePositionForkLoc
         );
@@ -1588,6 +1443,7 @@ 
     if(playSettings.allowResignation || playSettings.reduceVisits) {
       ReportedSearchValues values = toMoveBot->getRootValuesRequireSuccess();
+      historicalMctsDrawrate.push_back(values.noResultValue);
       historicalMctsWinLossValues.push_back(values.winLossValue);
       historicalMctsLeads.push_back(values.lead);
       historicalMctsScoreStdevs.push_back(values.expectedScoreStdev);
@@ -1608,7 +1464,7 @@ 
     //And make the move on our copy of the board
     assert(hist.isLegal(board,loc,pla));
-    hist.makeBoardMoveAssumeLegal(board,loc,pla,NULL);
+    hist.makeBoardMoveAssumeLegal(board,loc,pla);
 
     //Check for resignation
     if(playSettings.allowResignation && historicalMctsWinLossValues.size() >= playSettings.resignConsecTurns) {
@@ -1638,8 +1494,19 @@       }
     }
 
-    testAssert(hist.moveHistory.size() < 0x1FFFffff);
-    int nextTurnIdx = (int)hist.moveHistory.size();
+    //Check for drawEarlyEndGame
+    if (drawEarlyEndGame&&historicalMctsDrawrate.size()>=5)
+    {
+      bool shouldEndGameDraw = true;
+      for (int i = 0; i < 5; i++)
+      {
+        if (historicalMctsDrawrate[historicalMctsDrawrate.size() - i - 1] < 0.99)
+          shouldEndGameDraw = false;
+      }
+      if (shouldEndGameDraw)hist.setWinner(C_EMPTY);
+    }
+
+    int nextTurnIdx = hist.moveHistory.size();
     maybeCheckForNewNNEval(nextTurnIdx);
 
     pla = getOpp(pla);
@@ -1651,12 +1518,6 @@   else
     gameData->hitTurnLimit = true;
 
-  {
-    BoardHistory histCopy(hist);
-    //Always use true for computing the handicap value that goes into an sgf
-    histCopy.setAssumeMultipleStartingBlackMovesAreHandicap(true);
-    gameData->handicapForSgf = histCopy.computeNumHandicapStones();
-  }
 
   if(recordFullData) {
     if(hist.isResignation)
@@ -1671,7 +1532,11 @@     gameData->finalOwnership = new Color[Board::MAX_ARR_SIZE];
     gameData->finalSekiAreas = new bool[Board::MAX_ARR_SIZE];
 
-    if(hist.isGameFinished && hist.isNoResult) {
+    std::fill(gameData->finalFullArea,gameData->finalFullArea+Board::MAX_ARR_SIZE,C_EMPTY);
+    std::fill(gameData->finalOwnership,gameData->finalOwnership+Board::MAX_ARR_SIZE,C_EMPTY);
+    std::fill(gameData->finalSekiAreas,gameData->finalSekiAreas+Board::MAX_ARR_SIZE,false);
+
+    if (hist.isGameFinished &&( hist.isNoResult)) {
       finalValueTargets.win = 0.0f;
       finalValueTargets.loss = 0.0f;
       finalValueTargets.noResult = 1.0f;
@@ -1679,38 +1544,17 @@ 
       //Fill with empty so that we use "nobody owns anything" as the training target.
       //Although in practice actually the training normally weights by having a result or not, so it doesn't matter what we fill.
-      std::fill(gameData->finalFullArea,gameData->finalFullArea+Board::MAX_ARR_SIZE,C_EMPTY);
-      std::fill(gameData->finalOwnership,gameData->finalOwnership+Board::MAX_ARR_SIZE,C_EMPTY);
-      std::fill(gameData->finalSekiAreas,gameData->finalSekiAreas+Board::MAX_ARR_SIZE,false);
-    }
-    else {
-      //Relying on this to be idempotent, so that we can get the final territory map
-      //We also do want to call this here to force-end the game if we crossed a move limit.
-      hist.endAndScoreGameNow(board,gameData->finalOwnership);
-
+    }
+    else if (hist.isGameFinished) {
       finalValueTargets.win = (float)ScoreValue::whiteWinsOfWinner(hist.winner, gameData->drawEquivalentWinsForWhite);
       finalValueTargets.loss = 1.0f - finalValueTargets.win;
       finalValueTargets.noResult = 0.0f;
-      finalValueTargets.score = (float)ScoreValue::whiteScoreDrawAdjust(hist.finalWhiteMinusBlackScore,gameData->drawEquivalentWinsForWhite,hist);
+      finalValueTargets.score = 0.0f;
       finalValueTargets.hasLead = true;
       finalValueTargets.lead = finalValueTargets.score;
 
-      //Fill full and seki areas
-      {
-        board.calculateArea(gameData->finalFullArea, true, true, true, hist.rules.multiStoneSuicideLegal);
-
-        Color* independentLifeArea = new Color[Board::MAX_ARR_SIZE];
-        int whiteMinusBlackIndependentLifeRegionCount;
-        board.calculateIndependentLifeArea(independentLifeArea,whiteMinusBlackIndependentLifeRegionCount, false, false, hist.rules.multiStoneSuicideLegal);
-        for(int i = 0; i<Board::MAX_ARR_SIZE; i++) {
-          if(independentLifeArea[i] == C_EMPTY && (gameData->finalFullArea[i] == C_BLACK || gameData->finalFullArea[i] == C_WHITE))
-            gameData->finalSekiAreas[i] = true;
-          else
-            gameData->finalSekiAreas[i] = false;
-        }
-        delete[] independentLifeArea;
-      }
-    }
+    }
+    else std::cout << "Not finished game";
     gameData->whiteValueTargetsByTurn.push_back(finalValueTargets);
 
     //If we had a hintloc, then don't trust the first value, it will be corrupted a bit by the forced playouts.
@@ -1738,7 +1582,7 @@       double winValue = whiteValueTargetsByTurn[whiteValueTargetsByTurn.size()-1].win;
       double lossValue = whiteValueTargetsByTurn[whiteValueTargetsByTurn.size()-1].loss;
       double noResultValue = whiteValueTargetsByTurn[whiteValueTargetsByTurn.size()-1].noResult;
-      for(int i = (int)rawNNValues.size()-1; i >= 0; i--) {
+      for(int i = rawNNValues.size()-1; i >= 0; i--) {
         winValue = winValue + nowFactor * (whiteValueTargetsByTurn[i].win - winValue);
         lossValue = lossValue + nowFactor * (whiteValueTargetsByTurn[i].loss - lossValue);
         noResultValue = noResultValue + nowFactor * (whiteValueTargetsByTurn[i].noResult - noResultValue);
@@ -1758,17 +1602,17 @@ 
     //Compute desired expectation with which to write main game rows
     if(playSettings.policySurpriseDataWeight > 0 || playSettings.valueSurpriseDataWeight > 0) {
-      size_t numWeights = gameData->targetWeightByTurn.size();
-      assert(numWeights == gameData->policySurpriseByTurn.size());
+      int numWeights = gameData->targetWeightByTurn.size();
+      assert(numWeights == policySurpriseByTurn.size());
 
       double sumWeights = 0.0;
       double sumPolicySurpriseWeighted = 0.0;
       double sumValueSurpriseWeighted = 0.0;
-      for(size_t i = 0; i < numWeights; i++) {
+      for(int i = 0; i<numWeights; i++) {
         float targetWeight = gameData->targetWeightByTurn[i];
         assert(targetWeight >= 0.0 && targetWeight <= 1.0);
         sumWeights += targetWeight;
-        double policySurprise = gameData->policySurpriseByTurn[i];
+        double policySurprise = policySurpriseByTurn[i];
         assert(policySurprise >= 0.0);
         double valueSurprise = valueSurpriseByTurn[i];
         assert(valueSurprise >= 0.0);
@@ -1799,7 +1643,7 @@         double sumValueSurprisePropValue = 0.0;
         for(int i = 0; i<numWeights; i++) {
           float targetWeight = gameData->targetWeightByTurn[i];
-          double policySurprise = gameData->policySurpriseByTurn[i];
+          double policySurprise = policySurpriseByTurn[i];
           double valueSurprise = valueSurpriseByTurn[i];
           double policySurprisePropValue =
             targetWeight * policySurprise + (1-targetWeight) * std::max(0.0,policySurprise-thresholdToIncludeReduced);
@@ -1815,7 +1659,7 @@ 
         for(int i = 0; i<numWeights; i++) {
           float targetWeight = gameData->targetWeightByTurn[i];
-          double policySurprise = gameData->policySurpriseByTurn[i];
+          double policySurprise = policySurpriseByTurn[i];
           double valueSurprise = valueSurpriseByTurn[i];
           double policySurprisePropValue =
             targetWeight * policySurprise + (1-targetWeight) * std::max(0.0,policySurprise-thresholdToIncludeReduced);
@@ -1835,8 +1679,6 @@     for(int i = 0; i<sidePositionsToSearch.size(); i++) {
       SidePosition* sp = sidePositionsToSearch[i];
 
-      if(shouldPause != nullptr)
-        shouldPause->waitUntilFalse();
       if(shouldStop != nullptr && shouldStop()) {
         delete sp;
         continue;
@@ -1850,19 +1692,10 @@ 
       extractPolicyTarget(sp->policyTarget, toMoveBot, toMoveBot->rootNode, locsBuf, playSelectionValuesBuf);
       extractValueTargets(sp->whiteValueTargets, toMoveBot, toMoveBot->rootNode);
-
-      double policySurprise = 0.0, policyEntropy = 0.0, searchEntropy = 0.0;
-      bool success = toMoveBot->getPolicySurpriseAndEntropy(policySurprise, searchEntropy, policyEntropy);
-      assert(success);
-      (void)success; //Avoid warning when asserts are disabled
-      sp->policySurprise = policySurprise;
-      sp->policyEntropy = policyEntropy;
-      sp->searchEntropy = searchEntropy;
-
       sp->nnRawStats = computeNNRawStats(toMoveBot, sp->board, sp->hist, sp->pla);
       sp->targetWeight = 1.0f;
       sp->unreducedNumVisits = toMoveBot->getRootVisits();
-      sp->numNeuralNetChangesSoFar = (int)gameData->changedNeuralNets.size();
+      sp->numNeuralNetChangesSoFar = gameData->changedNeuralNets.size();
 
       gameData->sidePositions.push_back(sp);
 
@@ -1875,7 +1708,7 @@           sp->board,sp->hist,sp->pla,
           toMoveBot,
           playSettings.recordTreeThreshold,playSettings.recordTreeTargetWeight,
-          (int)gameData->changedNeuralNets.size(),
+          gameData->changedNeuralNets.size(),
           locsBuf,playSelectionValuesBuf,
           Board::NULL_LOC, Board::NULL_LOC
         );
@@ -1887,8 +1720,8 @@         if(responseLoc == Board::NULL_LOC || !sp->hist.isLegal(sp->board,responseLoc,sp->pla))
           failIllegalMove(toMoveBot,logger,sp->board,responseLoc);
 
-        SidePosition* sp2 = new SidePosition(sp->board,sp->hist,sp->pla,(int)gameData->changedNeuralNets.size());
-        sp2->hist.makeBoardMoveAssumeLegal(sp2->board,responseLoc,sp2->pla,NULL);
+        SidePosition* sp2 = new SidePosition(sp->board,sp->hist,sp->pla,gameData->changedNeuralNets.size());
+        sp2->hist.makeBoardMoveAssumeLegal(sp2->board,responseLoc,sp2->pla);
         sp2->pla = getOpp(sp2->pla);
         if(sp2->hist.isGameFinished)
           delete sp2;
@@ -1903,7 +1736,7 @@           Loc banMove = Board::NULL_LOC;
           Loc forkLoc = chooseRandomForkingMove(nnResultBuf.result.get(), sp2->board, sp2->hist, sp2->pla, gameRand, banMove);
           if(forkLoc != Board::NULL_LOC) {
-            sp2->hist.makeBoardMoveAssumeLegal(sp2->board,forkLoc,sp2->pla,NULL);
+            sp2->hist.makeBoardMoveAssumeLegal(sp2->board,forkLoc,sp2->pla);
             sp2->pla = getOpp(sp2->pla);
             if(sp2->hist.isGameFinished) delete sp2;
             else sidePositionsToSearch.push_back(sp2);
@@ -1911,8 +1744,7 @@         }
       }
 
-      testAssert(gameData->endHist.moveHistory.size() < 0x1FFFffff);
-      maybeCheckForNewNNEval((int)gameData->endHist.moveHistory.size());
+      maybeCheckForNewNNEval(gameData->endHist.moveHistory.size());
     }
 
     if(playSettings.scaleDataWeight != 1.0) {
@@ -1949,58 +1781,6 @@     }
 
 
-    //Fill in lead estimation on full-search positions
-    if(playSettings.estimateLeadProb > 0.0) {
-      assert(gameData->targetWeightByTurn.size() + 1 == gameData->whiteValueTargetsByTurn.size());
-      board = gameData->startBoard;
-      hist = gameData->startHist;
-      pla = gameData->startPla;
-
-      testAssert(gameData->startHist.moveHistory.size() < 0x1FFFffff);
-      testAssert(gameData->endHist.moveHistory.size() < 0x1FFFffff);
-      testAssert(gameData->endHist.moveHistory.size() >= gameData->startHist.moveHistory.size());
-      int startTurnIdx = (int)gameData->startHist.moveHistory.size();
-      int numMoves = (int)(gameData->endHist.moveHistory.size() - gameData->startHist.moveHistory.size());
-      for(int turnAfterStart = 0; turnAfterStart<numMoves; turnAfterStart++) {
-        int turnIdx = turnAfterStart + startTurnIdx;
-        if(gameData->targetWeightByTurn[turnAfterStart] > 0 &&
-           //Avoid computing lead when no result was considered to be very likely, since in such cases
-           //the relationship between komi and the result can somewhat break.
-           gameData->whiteValueTargetsByTurn[turnAfterStart].noResult < 0.3 &&
-           gameRand.nextBool(playSettings.estimateLeadProb)
-        ) {
-          if(shouldPause != nullptr)
-            shouldPause->waitUntilFalse();
-          if(shouldStop != nullptr && shouldStop())
-            break;
-
-          gameData->whiteValueTargetsByTurn[turnAfterStart].lead =
-            PlayUtils::computeLead(botB,botW,board,hist,pla,playSettings.estimateLeadVisits,otherGameProps);
-          gameData->whiteValueTargetsByTurn[turnAfterStart].hasLead = true;
-        }
-        Move move = gameData->endHist.moveHistory[turnIdx];
-        assert(move.pla == pla);
-        hist.makeBoardMoveAssumeLegal(board, move.loc, move.pla, NULL);
-        pla = getOpp(pla);
-      }
-
-      for(int i = 0; i<gameData->sidePositions.size(); i++) {
-        SidePosition* sp = gameData->sidePositions[i];
-        if(sp->targetWeight > 0 &&
-           sp->whiteValueTargets.noResult < 0.3 &&
-           gameRand.nextBool(playSettings.estimateLeadProb)
-        ) {
-          if(shouldPause != nullptr)
-            shouldPause->waitUntilFalse();
-          if(shouldStop != nullptr && shouldStop())
-            break;
-
-          sp->whiteValueTargets.lead =
-            PlayUtils::computeLead(botB,botW,sp->board,sp->hist,sp->pla,playSettings.estimateLeadVisits,otherGameProps);
-          sp->whiteValueTargets.hasLead = true;
-        }
-      }
-    }
   }
 
   return gameData;
@@ -2010,11 +1790,7 @@   board = finishedGameData->startHist.initialBoard;
   pla = finishedGameData->startHist.initialPla;
 
-  if(rules.scoringRule == Rules::SCORING_AREA)
-    hist.clear(board,pla,rules,0);
-  else
-    hist.clear(board,pla,rules,finishedGameData->startHist.initialEncorePhase);
-
+    hist.clear(board,pla,rules);
   //Make sure it's prior to the last move
   if(finishedGameData->endHist.moveHistory.size() <= 0)
     return;
@@ -2026,7 +1802,7 @@     if(!hist.isLegal(board,loc,pla)) {
       //We have a bug of some sort if we got an illegal move on replay, unless
       //we are in encore phase (pass for ko may change) or the rules are different
-      if(rules == finishedGameData->startHist.rules && hist.encorePhase == 0) {
+      if(rules == finishedGameData->startHist.rules ) {
         cout << board << endl;
         cout << PlayerIO::colorToChar(pla) << endl;
         cout << Location::toString(loc,board) << endl;
@@ -2038,7 +1814,7 @@       return;
     }
     assert(finishedGameData->endHist.moveHistory[i].pla == pla);
-    hist.makeBoardMoveAssumeLegal(board,loc,pla,NULL);
+    hist.makeBoardMoveAssumeLegal(board,loc,pla);
     pla = getOpp(pla);
 
     if(hist.isGameFinished)
@@ -2046,18 +1822,6 @@   }
 }
 
-static bool hasUnownedSpot(const FinishedGameData* finishedGameData) {
-  assert(finishedGameData->finalOwnership != NULL);
-  const Board& board = finishedGameData->startBoard;
-  for(int y = 0; y<board.y_size; y++) {
-    for(int x = 0; x<board.x_size; x++) {
-      Loc loc = Location::getLoc(x,y,board.x_size);
-      if(finishedGameData->finalOwnership[loc] == C_EMPTY)
-        return true;
-    }
-  }
-  return false;
-}
 
 void Play::maybeForkGame(
   const FinishedGameData* finishedGameData,
@@ -2071,9 +1835,6 @@   assert(finishedGameData->startHist.initialBoard.pos_hash == finishedGameData->endHist.initialBoard.pos_hash);
   assert(finishedGameData->startHist.initialPla == finishedGameData->endHist.initialPla);
 
-  //Just for conceptual simplicity, don't early fork games that started in the encore
-  if(finishedGameData->startHist.encorePhase != 0)
-    return;
   bool earlyFork = gameRand.nextBool(playSettings.earlyForkGameProb);
   bool lateFork = !earlyFork && playSettings.forkGameProb > 0 ? gameRand.nextBool(playSettings.forkGameProb) : false;
   if(!earlyFork && !lateFork)
@@ -2089,7 +1850,7 @@     );
   }
   else if(lateFork) {
-    moveIdx = finishedGameData->endHist.moveHistory.size() <= 0 ? 0 : (int)gameRand.nextUInt((uint32_t)finishedGameData->endHist.moveHistory.size());
+    moveIdx = finishedGameData->endHist.moveHistory.size() <= 0 ? 0 : (int)gameRand.nextUInt(finishedGameData->endHist.moveHistory.size());
   }
   else {
     ASSERT_UNREACHABLE;
@@ -2130,7 +1891,7 @@     Loc loc = possibleMoves[i];
     Board copy = board;
     BoardHistory copyHist = hist;
-    copyHist.makeBoardMoveAssumeLegal(copy,loc,pla,NULL);
+    copyHist.makeBoardMoveAssumeLegal(copy,loc,pla);
     MiscNNInputParams nnInputParams;
     nnInputParams.drawEquivalentWinsForWhite = drawEquivalentWinsForWhite;
     bot->nnEvaluator->evaluate(copy,copyHist,getOpp(pla),nnInputParams,buf,false,false);
@@ -2144,56 +1905,16 @@ 
   //Make that move
   assert(hist.isLegal(board,bestMove,pla));
-  hist.makeBoardMoveAssumeLegal(board,bestMove,pla,NULL);
+  hist.makeBoardMoveAssumeLegal(board,bestMove,pla);
   pla = getOpp(pla);
 
   //If the game is over now, don't actually do anything
   if(hist.isGameFinished)
     return;
-  forkData->add(new InitialPosition(board,hist,pla,true,false,false));
-}
-
-
-void Play::maybeSekiForkGame(
-  const FinishedGameData* finishedGameData,
-  ForkData* forkData,
-  const PlaySettings& playSettings,
-  const GameInitializer* gameInit,
-  Rand& gameRand
-) {
-  if(forkData == NULL)
-    return;
-  if(playSettings.sekiForkHackProb <= 0)
-    return;
-
-  //If there are any unowned spots, consider forking the last bit of the game, with random rules and even score
-  //Don't fork games starting in second encore though
-  const BoardHistory& endHist = finishedGameData->endHist;
-  if(endHist.isGameFinished && endHist.isScored && finishedGameData->startHist.encorePhase < 2 && hasUnownedSpot(finishedGameData)) {
-
-    for(int i = 0; i<2; i++) {
-      //Pick a random move to fork from near the end of the game
-      int moveIdx = (int)floor(endHist.moveHistory.size() * (1.0 - 0.10 * gameRand.nextExponential()) - 1.0);
-      if(moveIdx < 0)
-        moveIdx = 0;
-      if(moveIdx > endHist.moveHistory.size())
-        moveIdx = (int)endHist.moveHistory.size();
-
-      //Randomly permute the rules
-      Rules rules = finishedGameData->startHist.rules;
-      rules = gameInit->randomizeScoringAndTaxRules(rules,gameRand);
-
-      Board board;
-      Player pla;
-      BoardHistory hist;
-      replayGameUpToMove(finishedGameData, moveIdx, rules, board, hist, pla);
-      //Just in case if somehow the game is over now, don't actually do anything
-      if(hist.isGameFinished)
-        continue;
-      forkData->addSeki(new InitialPosition(board,hist,pla,false,true,false),gameRand);
-    }
-  }
-}
+  forkData->add(new InitialPosition(board,hist,pla,true,false));
+}
+
+
 
 void Play::maybeHintForkGame(
   const FinishedGameData* finishedGameData,
@@ -2202,9 +1923,6 @@ ) {
   if(forkData == NULL)
     return;
-  //Just for conceptual simplicity, don't early fork games that started in the encore
-  if(finishedGameData->startHist.encorePhase != 0)
-    return;
   bool hintFork =
     otherGameProps.hintLoc != Board::NULL_LOC &&
     finishedGameData->startBoard.pos_hash == otherGameProps.hintPosHash &&
@@ -2218,9 +1936,7 @@   Board board;
   Player pla;
   BoardHistory hist;
-  testAssert(finishedGameData->startHist.moveHistory.size() < 0x1FFFffff);
-  int moveIdxToReplayTo = (int)finishedGameData->startHist.moveHistory.size();
-  replayGameUpToMove(finishedGameData, moveIdxToReplayTo, finishedGameData->startHist.rules, board, hist, pla);
+  replayGameUpToMove(finishedGameData, finishedGameData->startHist.moveHistory.size(), finishedGameData->startHist.rules, board, hist, pla);
   //Just in case if somehow the game is over now, don't actually do anything
   if(hist.isGameFinished)
     return;
@@ -2228,13 +1944,13 @@   if(!hist.isLegal(board,otherGameProps.hintLoc,pla))
     return;
 
-  hist.makeBoardMoveAssumeLegal(board,otherGameProps.hintLoc,pla,NULL);
+  hist.makeBoardMoveAssumeLegal(board,otherGameProps.hintLoc,pla);
   pla = getOpp(pla);
 
   //If the game is over now, don't actually do anything
   if(hist.isGameFinished)
     return;
-  forkData->add(new InitialPosition(board,hist,pla,false,false,true));
+  forkData->add(new InitialPosition(board,hist,pla,false,true));
 }
 
 
@@ -2281,7 +1997,6 @@   const Sgf::PositionSample* startPosSample,
   Logger& logger,
   const std::function<bool()>& shouldStop,
-  const WaitableFlag* shouldPause,
   std::function<NNEvaluator*()> checkForNewNNEval,
   std::function<void(const MatchPairer::BotSpec&, Search*)> afterInitialization,
   std::function<void(const Board&, const BoardHistory&, Player, Loc, const std::vector<double>&, const std::vector<double>&, const std::vector<double>&, const Search*)> onEachMove
@@ -2292,15 +2007,9 @@   Rand gameRand(seed + ":" + "forGameRand");
 
   const InitialPosition* initialPosition = NULL;
-  bool usedSekiForkHackPosition = false;
   if(forkData != NULL) {
     initialPosition = forkData->get(gameRand);
 
-    if(initialPosition == NULL && playSettings.sekiForkHackProb > 0 && gameRand.nextBool(playSettings.sekiForkHackProb)) {
-      initialPosition = forkData->getSeki(gameRand);
-      if(initialPosition != NULL)
-        usedSekiForkHackPosition = true;
-    }
   }
 
   Board board;
@@ -2370,7 +2079,6 @@     doEndGameIfAllPassAlive,clearBotBeforeSearchThisGame,
     logger,logSearchInfo,logMoves,
     maxMovesPerGame,shouldStop,
-    shouldPause,
     playSettings,otherGameProps,
     gameRand,
     checkForNewNNEval, //Note that if this triggers, botSpecB and botSpecW will get updated, for use in maybeForkGame
@@ -2392,9 +2100,6 @@   assert(finishedGameData != NULL);
 
   Play::maybeForkGame(finishedGameData, forkData, playSettings, gameRand, botB);
-  if(!usedSekiForkHackPosition) {
-    Play::maybeSekiForkGame(finishedGameData, forkData, playSettings, gameInit, gameRand);
-  }
   Play::maybeHintForkGame(finishedGameData, forkData, otherGameProps);
 
   if(botW != botB)
